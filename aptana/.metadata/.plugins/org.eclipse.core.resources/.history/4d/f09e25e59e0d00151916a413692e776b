/** This is the main service for retrieving data at regular intervals.
 *
 */

(function() {
	angular.module('main').factory('Data', ['$rootScope', '$http', '$log', 'net',
	function($rootScope, $http, $log, net) {

		/* Contains data specific to the PAS */
		function pasData(){
			this.f0 = [];
			this.IA = [];
			this.Q = [];
			this.p = [];
			this.abs = [];
			this.micf =[];
			this.mict = [];
			this.pd = [];
		}; 
		
		function crdObject(){
			this.tau = [];
			this.tau0 = [];
			this.taucorr = [];
			"tau0corr" : [],
			"ext" : [],
			"extcorr" : [],
			"stdvTau" : [],
			"etau" : [],
			"max" : []
		};

		/* The full data object contains arrays of data as defined in the objects above */
		var dataObj = {
			"time" : null,
			"filter" : true,
			"save" : true,
			"o3cal" : false
		};
		
		// Defines array lengths - 100 == 100 seconds of data
		var maxLength = 300;
		dataObj.pas = {};
		dataObj.pas.cell = [new pasData()];
		dataObj.pas.drive = true;

		/* Call this to poll the server for data */
		dataObj.getData = function() {
			promise = $http.get('http://' + net.address() + '/xService/General/Data').success(function(data, status, headers, config) {
				$rootScope.$broadcast('dataAvailable');
				
				// Time comes back in string format so no need to translate...
				dataObj.time = data.Time;

				// TODO: Fix this hideousness!!!  Has to be a better way...
				for (var index in data.PAS.CellData) {

					/* Make sure we have all of the cells accounted for */
					if ((dataObj.pas.cell.length - 1) < index) {
						dataObj.pas.cell.push(new pasData());
					}

					/* Handle the resonant frequency data */
					if (dataObj.pas.cell[index].f0.length >= maxLength) {
						dataObj.pas.cell[index].f0.pop();
					}

					dataObj.pas.cell[index].f0.unshift(data.PAS.CellData[index].derived.f0);

					/* Handle the integrated area data */
					if (dataObj.pas.cell[index].IA.length >= maxLength) {
						dataObj.pas.cell[index].IA.pop();
					}

					dataObj.pas.cell[index].IA.unshift(data.PAS.CellData[index].derived.IA);

					/* Handle the quality data */
					if (dataObj.pas.cell[index].Q.length >= maxLength) {
						dataObj.pas.cell[index].Q.pop();
					}
					dataObj.pas.cell[index].Q.unshift(data.PAS.CellData[index].derived.Q);
					
					/* Handle the noise limit data */
					if (dataObj.pas.cell[index].p.length >= maxLength) {
						dataObj.pas.cell[index].p.pop();
					}
					dataObj.pas.cell[index].p.unshift(data.PAS.CellData[index].derived.noiseLim);
					
					/* Handle the absorption data */
					if (dataObj.pas.cell[index].abs.length >= maxLength) {
						dataObj.pas.cell[index].abs.pop();
					}
					dataObj.pas.cell[index].abs.unshift(data.PAS.CellData[index].derived.abs);
					
					dataObj.pas.cell[index].micf = data.PAS.MicFreq[index].Y;
					
					dataObj.pas.cell[index].mict = data.PAS.MicTime[index].Y;
					
					dataObj.pas.cell[index].pd = data.PAS.Photodiode[index].Y;
				
				}	
				dataObj.pas.drive = data.PAS.Drive;
			});
		};

		return dataObj;

	}]);
})();

